<?phprequire( __DIR__ . '/omo-calc-common.php' );require( __DIR__ . '/commonlib.php' );define( 'DEF_NUM_CLUST', 200 );define( 'NUM_DATASET', 10000 );define( 'DEF_FN_DB', 'omoclst_10000_1' );//. project name$pn = $argv[1];if ( ! $pn ) {	die( "使い方: {$argv[0]} [project name]" );}define( 'PROJ_NAME', $pn );define( 'DN_PROJ', '../omo_class/'. PROJ_NAME );if ( ! _mkdir( DN_PROJ ) ) 	die( 'プロジェクトディレクトリ作成失敗' );define( 'DN_PROJ', realpath( $dn ) );$fn_proj = DN_PROJ. '/proj.tsv';if ( ! file_exists( $fn_proj ) ) {	file_put_contents( $fn_proj, ''		. "num_class\t" .DEF_NUM_CLUST. "\n"		. "fn_db\t"     .DEF_FN_DB. "\n" 	);//	die( "プロジェクトファイル作成完了: $fn_proj" );}_line( 'Project', PROJ_NAME );_kvtable( PROJ_INFO, 'Project info' );define( 'PROJ_INFO', _tsv_load( $fn_proj ) );if ( PROJ_INFO[ 'fn_db' ] == '' || PROJ_INFO[ 'num_class' ] == '' ) {	die( 'プロジェクトファイルにデータが入っていない' );}define( 'FN_DB', "/ssd/sqlite/" . PROJ_INFO[ 'fn_db' ]. '.sqlite' );define( 'NUM_CLASS', PROJ_INFO[ 'num_class' ] );_kvtable([	'proj name' => PROJ_NAME ,	'proj dir'  => DN_PROJ ,	'DB name' => FN_DB ,	'num class' => NUM_CLASS], 'Project data');//. functions//.. _keta_formatfunction _keta_format( $num = '*', $keta = 3 ) {	if ( $num === '*'  )		return '*'; 	else		return substr( '0000000' . $num, $keta * -1 );}//.. _fn2function _fn2( $type, $cycle = '*', $val1 = '*' ) {	$ret = [		'dn_cls'    => 'cls<num>' ,		'cls'       => 'cls<num>/' . _keta_format( $val1 ) . '.tsv' ,		'profdb'    => 'prof<num>.sqlite' ,		'step'		=> 'step<num>.json' ,		'info'		=> 'info<num>.json' ,		'nodes_pdb' => "nodes_$cycle.pdb"	][ $type ];	if ( $ret == '' )		_die( 'ファイル名タイプが不明: ' . $type );	return DN_PROJ . '/' . strtr( $ret, [ '<num>' => _keta_format( $cycle )] );}//.. _prep_profdbfunction _prep_profdb( $fn ) {	if ( is_numeric( $fn ) )		$fn = _fn2( 'profdb', $fn );	_m( "書き込み用 DBファイル名: $fn" );	return new cls_sqlw([		'fn'	=> $fn ,		'new'	=> true ,		'cols'	=> [			'id	UNIQUE' ,			'data	BLOB' ,			'pca1	REAL' ,			'pca2	REAL' ,			'pca3	REAL'		],		'indexcols' => [ 'id', 'pca1', 'pca2', 'pca3' ]	]);}//.. _get_datafunction _get_data( $db, $id ) {	return $db->where([ "id=\"$id\"" ])->qcol([ 'select' => 'data' ])[0];}//.. _get_comp_parfunction _get_comp_par() {	$o = new cls_sqlite( FN_DB );	return _count_ign(		_bin2prof( $o->q(['select' => 'data' ])->fetchColumn() )	);}//.. _get_step_valfunction _get_step_val( $num ) {	_line( 'step', $num );	if ( ! defined( 'COMP_PARAM' ) )		define( 'COMP_PARAM', _get_comp_par() );	_m( '変異統計値計算: ' . ( $num - 1 ) . " => $num" );	$db1 = new cls_sqlite( _fn2( 'profdb', $num     ) );	$db2 = new cls_sqlite( _fn2( 'profdb', $num - 1 ) );	$scr_list = [];	foreach ( range( 0, NUM_CLASS -1 ) as $node_id ) {		$scr_list[] = _getscore(			_bin2prof( _get_data( $db1, $node_id ) ) ,			_bin2prof( _get_data( $db2, $node_id ) ) ,			COMP_PARAM		);	}	$step = _stat( $scr_list );	_m( json_encode( $step, JSON_PRETTY_PRINT ) );	_json_save( _fn2( 'step', $num ), $step );	return $step;}//.. _fn2numfunction _fn2num( $fn ) {	return _numonly( basename( $fn ) );}//.. _fn_lastfunction _fn_last( $type ) {	return array_slice( glob( _fn2( $type ) ), -1 )[0];}//.. _statfunction _stat( $data ) {	$num = count( $data );	$avg = array_sum( $data ) / $num;	$sigma = 0;	foreach ( $data as $val ) {		$sigma += pow( $val - $avg, 2 );	}	return [		'min' => min( $data ) ,		'max' => max( $data ) ,		'avg' => $avg ,		'sigma' => sqrt( $sigma / $num ) ,		'num' => $num	];}